Лекция. Курс компиляторов.

Разбор объявлений и выражений.
Таблица символов.

class SymTable
{
    Symbols
}


class SymVariable : Symbol
{
    
}

class SymType: Symbol
{
    
}

class SymFunction: Symbol
{
    params
    locals
    body - Operator : Statement : Node (Assignment, Expression)
}

операторы:
while
{
    cond: Expression
    body: Statement
}

Repeat -//-

if : statement
{
    cond: Expression
    body1: Statement
    body2: Statement
    (EmptyStatement)
}

for : statement
{
    e[3] : Expression
}

break, continue, return

!!!
Block : statement
{
    symtable
    statements
}


Parse возвращает указатель на таблицу символов, которая содержит глобальные
переменные.

Задача:  реализовать вот это.

Стэк таблиц символов
0. Окружение (char, int float, printf etc)
1. Global Symbol Table
2. ...

Операции со стэком таблиц символов:
1. искать символ (нельзя переопределеять то что на самом верхнем уровне)
2. добавлять символ
(категории таблиц символов: пространства имён структур и переменных не конфликтуют
например)

Имя структуры, тэг, тэгдеф???
Сразу объявление переменной.

Возможнные трудности (си):
Разбор типов данных.
Трюки: (проблема в том что мы не можем легко конструировать тип по частям
в языке си: int a[10] массив из десяти чисел,  int* a[10] - массив из 10 указателей
, int (*a)[10] указатель на массив из 10 символов)
Проблема в том, что мы как бы разобрали часть выражения:
    int a[10][21]; массив из десяти элементов, каждый из которых является массивом из 20 элементов, каждый
    из которых имеет тип int. Проблема в том, что объявление типа далеко от того
    момента, когда мы пониманием, что мы находимся в объявлении массива массивов.

1. Создавать типы заглушки. вместо типа, когда непонятно, какой тип. Потом подставляем
когда становится ясно что за тип.
2. Можно сжирать квадратные скобки в цикле. Но надо будет нарушить концепцию рекурсивного спуска+
Для функций, которые возвращают массив, указатель на массив или массив указателей на функции, которые возвращают массив. 
3. Можно пытаться применить трюк конструирования структуры данных на обратном ходе рекурсии.
Всё равно понядобятся промежуточные типы или удаление чего-то там.


Сборка мусора:
1. Аккуратный конструктор и деструктор (нетривиально, потому что может быть много ссылок на объект и 
больше одного пути, который попадает в одну и ту же точку. Избежать double delete)
2. РефКаунт 

SymType : SymArray { elementType может быть массивом }

Мы не будем реализовывать класс алгоритмов для выделения памяти.
Обращаться к операционной системе для выделением памяти плохо.


щ