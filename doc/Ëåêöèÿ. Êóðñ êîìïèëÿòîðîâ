Лекция. Курс компиляторов.

Разбор объявлений и выражений.
Таблица символов.

class SymTable
{
    Symbols
}


class SymVariable : Symbol
{
    
}

class SymType: Symbol
{
    
}

class SymFunction: Symbol
{
    params
    locals
    body - Operator : Statement : Node (Assignment, Expression)
}

операторы:
while
{
    cond: Expression
    body: Statement
}

Repeat -//-

if : statement
{
    cond: Expression
    body1: Statement
    body2: Statement
    (EmptyStatement)
}

for : statement
{
    e[3] : Expression
}

break, continue, return

!!!
Block : statement
{
    symtable
    statements
}


Parse возвращает указатель на таблицу символов, которая содержит глобальные
переменные.

Задача:  реализовать вот это.

Стэк таблиц символов
0. Окружение (char, int float, printf etc)
1. Global Symbol Table
2. ...

Операции со стэком таблиц символов:
1. искать символ (нельзя переопределеять то что на самом верхнем уровне)
2. добавлять символ
(категории таблиц символов: пространства имён структур и переменных не конфликтуют
например)

Имя структуры, тэг, тэгдеф???
Сразу объявление переменной.

Возможнные трудности (си):
Разбор типов данных.
Трюки: (проблема в том что мы не можем легко конструировать тип по частям
в языке си: int a[10] массив из десяти чисел,  int* a[10] - массив из 10 указателей
, int (*a)[10] указатель на массив из 10 символов)
Проблема в том, что мы как бы разобрали часть выражения:
    int a[10][21]; массив из десяти элементов, каждый из которых является массивом из 20 элементов, каждый
    из которых имеет тип int. Проблема в том, что объявление типа далеко от того
    момента, когда мы пониманием, что мы находимся в объявлении массива массивов.

1. Создавать типы заглушки. вместо типа, когда непонятно, какой тип. Потом подставляем
когда становится ясно что за тип.
2. Можно сжирать квадратные скобки в цикле. Но надо будет нарушить концепцию рекурсивного спуска+
Для функций, которые возвращают массив, указатель на массив или массив указателей на функции, которые возвращают массив. 
3. Можно пытаться применить трюк конструирования структуры данных на обратном ходе рекурсии.
Всё равно понядобятся промежуточные типы или удаление чего-то там.


Сборка мусора:
1. Аккуратный конструктор и деструктор (нетривиально, потому что может быть много ссылок на объект и 
больше одного пути, который попадает в одну и ту же точку. Избежать double delete)
2. РефКаунт 

SymType : SymArray { elementType может быть массивом }

Мы не будем реализовывать класс алгоритмов для выделения памяти.
Обращаться к операционной системе для выделением памяти плохо.


Следующий этап:
    
    В чём же состоят проверки? Во-первых мы проверяем для каждой операции совместимость
типов операндов. Тут у нас какие есть варианты? У нас есть совместимость типов для полиморфных операций.
Т.е. бинарных операций. С учётом того, что у нас три типа - чар, инт и доубле, то все типы совместимы с
соответствующими преобразованиями. Для того чтобы осуществлять проверку типов нам необходимо
сначала эти типы расчитать, т.е. нам необходимо какую-нибудь функцию типа GetType, которая будет
виртуальной в Expression и будет возвращать тип выражения. Для литералов всё просто,
для бинарных операций - комбинируем, всё. Для побитовых - ньюансы.

С указателями ньюансы. void* совместим со всем.

Обращения к записям. GetType - что-то типа единичного вызова GetType с самого верха, который
Проходит всё рекурсивно и сохраняет типы походу, находя ошибки.

Для вызовов функций надо проверить. 1. Количество аргументов совпадает, 
По значению: 2. последовательное соответствие типов. Exactly. 3. Типы совпадают - всё хорошо. 4. Допустимо повышение скалярных типов. (по значению). Указатель на что угодно -> указатель на void*.
Для массивов можно сделать exact match.

Для присваиваний 1. совпадение по типу с повышением. 2. l-value (допустимо взятие адреса)

В случае неявных преобразований (целое + вещественно) то при генерации кода
нам необходимо будет сгенерировать разный код для разных типов аргументов.
1. Усложнить генератор кода и написать n вариантов для сложения
2. На этапе определения типов модификацию дерева, которая вставит преобразование типов где нужно

Это на сл. занятие (через две недели)
Пар архитектуры в субботу не будет, потому что асм.

Простая инициализация обязательна и делается как присваивание.

    Q/A

Поддержка const - Да, в смысле только в объявлениях
Поддержка enum - выпилили
Сравнение типов объявленых typedef, считать равными!
За сколько min проходов можно всё сделать 2
Сложные инициализацторы - опциональны!

    Code generation

